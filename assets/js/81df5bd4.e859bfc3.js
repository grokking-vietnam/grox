"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[773],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return d}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function p(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var o=r.createContext({}),s=function(e){var t=r.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):p(p({},t),e)),n},c=function(e){var t=s(e.components);return r.createElement(o.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=s(n),d=a,g=m["".concat(o,".").concat(d)]||m[d]||u[d]||i;return n?r.createElement(g,p(p({ref:t},c),{},{components:n})):r.createElement(g,p({ref:t},c))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,p=new Array(i);p[0]=m;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l.mdxType="string"==typeof e?e:a,p[1]=l;for(var s=2;s<i;s++)p[s]=n[s];return r.createElement.apply(null,p)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},6522:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return o},metadata:function(){return s},toc:function(){return c},default:function(){return m}});var r=n(7462),a=n(3366),i=(n(7294),n(3905)),p=["components"],l={},o="Parsing Expression",s={unversionedId:"book/parsing-expression",id:"book/parsing-expression",title:"Parsing Expression",description:"Grammar rules",source:"@site/../grox-docs/target/mdoc/book/5-parsing-expression.md",sourceDirName:"book",slug:"/book/parsing-expression",permalink:"/grox/docs/book/parsing-expression",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/../grox-docs/target/mdoc/book/5-parsing-expression.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{},sidebar:"docs",previous:{title:"Representing Code",permalink:"/grox/docs/book/representing-code"},next:{title:"Parser Combinators",permalink:"/grox/docs/fp/parser-combinators"}},c=[{value:"Grammar rules",id:"grammar-rules",children:[],level:2},{value:"Expression parser",id:"expression-parser",children:[{value:"Parse function",id:"parse-function",children:[],level:3},{value:"Binary expression",id:"binary-expression",children:[],level:3},{value:"Unary expression",id:"unary-expression",children:[],level:3},{value:"Primary expression",id:"primary-expression",children:[],level:3}],level:2}],u={toc:c};function m(e){var t=e.components,n=(0,a.Z)(e,p);return(0,i.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"parsing-expression"},"Parsing Expression"),(0,i.kt)("h2",{id:"grammar-rules"},"Grammar rules"),(0,i.kt)("p",null,"\u1ede ",(0,i.kt)("a",{parentName:"p",href:"/grox/docs/book/representing-code"},"ph\u1ea7n tr\u01b0\u1edbc"),", ch\xfang ta bi\u1ebft r\u1eb1ng expression trong Lox c\xf3 th\u1ec3 \u0111\u01b0\u1ee3c generate theo nh\u1eefng quy t\u1eafc sau"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'expression     \u2192 literal\n               | unary\n               | binary\n               | grouping ;\n\nliteral        \u2192 NUMBER | STRING | "true" | "false" | "nil" ;\ngrouping       \u2192 "(" expression ")" ;\nunary          \u2192 ( "-" | "!" ) expression ;\nbinary         \u2192 expression operator expression ;\noperator       \u2192 "==" | "!=" | "<" | "<=" | ">" | ">="\n               | "+"  | "-"  | "*" | "/" ;\n')),(0,i.kt)("p",null,"X\xe9t bi\u1ec3u th\u1ee9c:\n",(0,i.kt)("img",{parentName:"p",src:"http://craftinginterpreters.com/image/parsing-expressions/tokens.png",alt:null})),(0,i.kt)("p",null,"S\u1eed d\u1ee5ng quy t\u1eafc tr\xean, c\xf3 hai c\xe1ch \u0111\u1ec3 generate ra bi\u1ec3u th\u1ee9c n\xe0y, v\xe0 cho ra hai k\u1ebft qu\u1ea3 kh\xe1c nhau!"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"http://craftinginterpreters.com/image/parsing-expressions/syntax-trees.png",alt:null})),(0,i.kt)("p",null,"Nh\u01b0 v\u1eady quy t\u1eafc grammar tr\xean c\xf3 s\u1ef1 m\u01a1 h\u1ed3 (ambiguity). Trong to\xe1n h\u1ecdc, v\u1ea5n \u0111\u1ec1 n\xe0y \u0111\u01b0\u1ee3c gi\u1ea3i quy\u1ebft b\u1eb1ng 2 lu\u1eadt"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Precedence"),": quy \u0111\u1ecbnh ph\xe9p to\xe1n \u0111\u01b0\u1ee3c t\xednh tr\u01b0\u1edbc trong m\u1ed9t bi\u1ec3u th\u1ee9c g\u1ed3m nhi\u1ec1u lo\u1ea1i ph\xe9p to\xe1n. E.g: ph\xe9p nh\xe2n (x) \u0111\u01b0\u1ee3c t\xednh tr\u01b0\u1edbc ph\xe9p c\u1ed9ng (+)."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"Precedence, lowest to highest\n| =\n| or\n| and\n| ==, !=\n| <, >, <=, >=\n| +, -\n| *, /\n| not, - (negate)\nv ()\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Associativity"),": quy \u0111\u1ecbnh to\xe1n t\u1eed \u0111\u01b0\u1ee3c t\xednh tr\u01b0\u1edbc trong m\u1ed9t bi\u1ec3u th\u1ee9c g\u1ed3m nhi\u1ec1u to\xe1n t\u1eed gi\u1ed1ng nhau."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Ph\xe9p c\u1ed9ng l\xe0 left-associate. E.g: 1 + 2 + 3 c\xf3 th\u1ec3 vi\u1ebft d\u01b0\u1edbi d\u1ea1ng (1 + 2) + 3"),(0,i.kt)("li",{parentName:"ul"},"Ph\xe9p g\xe1n (=) l\xe0 right-associate. E.g: x = y = z c\xf3 th\u1ec3 vi\u1ebft d\u01b0\u1edbi d\u1ea1ng x = (y = z)")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"| Name        | Operator     | Associativity |\n| --------    | --------     | -------- |\n| Equality    | ==, !=       | Left     |\n| Comparison  | >, >=, <, <= | Left     |\n| Term        | +, -         | Left     |\n| Factor      | * /          | Left     |\n| Unary       | !, -         | Right    |\n")),(0,i.kt)("p",null,"D\u1ef1a v\xe0o lu\u1eadt precedence v\xe0 associativity, ta c\xf3 th\u1ec3 vi\u1ebft l\u1ea1i ng\u1eef ph\xe1p cho expression nh\u1eb1m lo\u1ea1i b\u1ecf s\u1ef1 m\u01a1 h\u1ed3 c\u1ee7a ng\u1eef ph\xe1p \u1edf ph\u1ea7n tr\u01b0\u1edbc:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'expression     \u2192 equality ;\nequality       \u2192 comparison ( ( "!=" | "==" ) comparison )* ;\ncomparison     \u2192 term ( ( ">" | ">=" | "<" | "<=" ) term )* ;\nterm           \u2192 factor ( ( "-" | "+" ) factor )* ;\nfactor         \u2192 unary ( ( "/" | "*" ) unary )* ;\nunary          \u2192 ( "!" | "-" ) unary\n               | primary ;\nprimary        \u2192 NUMBER | STRING | "true" | "false" | "nil"\n               | "(" expression ")" ;\n')),(0,i.kt)("p",null,"D\u01b0\u1edbi \u0111\xe2y, parser s\u1ebd \u0111\u01b0\u1ee3c c\xe0i \u0111\u1eb7t theo ng\u1eef ph\xe1p n\xe0y."),(0,i.kt)("h2",{id:"expression-parser"},"Expression parser"),(0,i.kt)("p",null,"Trong ph\u1ea7n n\xe0y, ta s\u1eed d\u1ee5ng k\u0129 thu\u1eadt parsing c\xf3 t\xean Recursive Descent Parsing. K\u0129 thu\u1eadt n\xe0y c\xf3 c\xe1ch ti\u1ebfp c\u1eadn ",(0,i.kt)("strong",{parentName:"p"},"top-down"),", t\u1ee9c l\xe0 b\u1eaft \u0111\u1ea7u t\u1eeb rule tr\xean c\xf9ng (expression) v\xe0 d\u1ea7n d\u1ea7n \u0111i xu\u1ed1ng t\u1eebng t\u1ea7ng cho \u0111\u1ebfn rule cu\u1ed1i c\xf9ng (primary)."),(0,i.kt)("h3",{id:"parse-function"},"Parse function"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"  // Parse a single expression and return remaining tokens\n  def parse(ts: List[Token]): ParseResult = expression(ts)\n\n  def expression(tokens: List[Token]): ParseResult = equality(tokens)\n")),(0,i.kt)("p",null,"Parse function tr\u1ea3 ra ",(0,i.kt)("strong",{parentName:"p"},"m\u1ed9t")," expression ho\xe0n ch\u1ec9nh v\xe0 tokens c\xf2n l\u1ea1i sau qu\xe1 tr\xecnh parse."),(0,i.kt)("p",null,"M\u1ed7i rule (e.g: expression, equality, etc) s\u1ebd t\u01b0\u01a1ng \u1ee9ng v\u1edbi m\u1ed9t h\xe0m v\xe0 c\xf3 ki\u1ec3u input/output t\u01b0\u01a1ng t\u1ef1 h\xe0m ",(0,i.kt)("inlineCode",{parentName:"p"},"parse"),"."),(0,i.kt)("h3",{id:"binary-expression"},"Binary expression"),(0,i.kt)("p",null,"H\xe3y b\u1eaft \u0111\u1ea7u v\u1edbi v\xed d\u1ee5:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Parse bi\u1ec3u th\u1ee9c ",(0,i.kt)("strong",{parentName:"p"},"a * b + c - d"))),(0,i.kt)("p",null,"Bi\u1ec3u th\u1ee9c tr\xean \u0111\u01b0\u1ee3c vi\u1ebft d\u01b0\u1edbi d\u1ea1ng tokens nh\u01b0 sau"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"| a | * | b | + | c | - | d | ; |\n")),(0,i.kt)("p",null,"Rule \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 parse l\xe0"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'term           \u2192 factor ( ( "-" | "+" ) factor )* ;\n')),(0,i.kt)("p",null,"C\xe1c b\u01b0\u1edbc trong qu\xe1 tr\xecnh parse s\u1ebd di\u1ec5n ra nh\u01b0 sau"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Step"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"),(0,i.kt)("th",{parentName:"tr",align:null},"Expr"),(0,i.kt)("th",{parentName:"tr",align:null},"Remaining tokens"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"0"),(0,i.kt)("td",{parentName:"tr",align:null},"Kh\u1edfi \u0111\u1ea7u"),(0,i.kt)("td",{parentName:"tr",align:null},"(?)"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"a * b + c - d ;"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"1"),(0,i.kt)("td",{parentName:"tr",align:null},"Ch\u1ea1y rule ",(0,i.kt)("inlineCode",{parentName:"td"},"factor(a * b + c - d ;)")),(0,i.kt)("td",{parentName:"tr",align:null},"a * b"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"+ c - d ;"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"2"),(0,i.kt)("td",{parentName:"tr",align:null},"Th\xeam d\u1ea5u +"),(0,i.kt)("td",{parentName:"tr",align:null},"a * b + (?)"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"c - d ;"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"3"),(0,i.kt)("td",{parentName:"tr",align:null},"Ch\u1ea1y rule ",(0,i.kt)("inlineCode",{parentName:"td"},"factor(c - d ;)")),(0,i.kt)("td",{parentName:"tr",align:null},"a * b + c"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"- d ;"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"4"),(0,i.kt)("td",{parentName:"tr",align:null},"Th\xeam d\u1ea5u -"),(0,i.kt)("td",{parentName:"tr",align:null},"a * b + c - (?)"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"d ;"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"5"),(0,i.kt)("td",{parentName:"tr",align:null},"Ch\u1ea1y rule ",(0,i.kt)("inlineCode",{parentName:"td"},"factor(d ;)")),(0,i.kt)("td",{parentName:"tr",align:null},"a * b + c - d"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},";"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"6"),(0,i.kt)("td",{parentName:"tr",align:null},"K\u1ebft th\xfac"),(0,i.kt)("td",{parentName:"tr",align:null},"a * b + c - d"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},";"))))),(0,i.kt)("p",null,"M\u1eb7c d\xf9 v\xed d\u1ee5 \u1edf tr\xean gi\u1ea3i th\xedch c\xe1c b\u01b0\u1edbc parse ph\xe9p c\u1ed9ng (term), nh\u01b0ng ta ho\xe0n to\xe0n c\xf3 th\u1ec3 \xe1p d\u1ee5ng thu\u1eadt to\xe1n n\xe0y cho c\xe1c ph\xe9p to\xe1n nh\u1ecb ph\xe2n (binary expression) kh\xe1c."),(0,i.kt)("p",null,"Trong Scala, thu\u1eadt to\xe1n tr\xean \u0111\u01b0\u1ee3c c\xe0i \u0111\u1eb7t nh\u01b0 sau:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"  def binary(\n    op: BinaryOp,\n    descendant: List[Token] => ParseResult,\n  )(\n    tokens: List[Token]\n  ): ParseResult =\n    def matchOp(ts: List[Token], l: Expr): ParseResult =\n      ts match\n        case token :: rest =>\n          op(token) match\n            case Some(fn) => descendant(rest).flatMap((r, rmn) => matchOp(rmn, fn(l, r)))\n            case None     => Right(l, ts)\n        case _ => Right(l, ts)\n\n    descendant(tokens).flatMap((expr, rest) => matchOp(rest, expr))\n")),(0,i.kt)("p",null,"sau \u0111\xf3 c\xf3 th\u1ec3 s\u1eed d\u1ee5ng h\xe0m n\xe0y n\xe0y cho c\xe1c ph\xe9p to\xe1n nh\u1ecb ph\xe2n"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"  def equality = binary(equalityOp, comparison)\n  def comparison = binary(comparisonOp, term)\n  def term = binary(termOp, factor)\n  def factor = binary(factorOp, unary)\n")),(0,i.kt)("h3",{id:"unary-expression"},"Unary expression"),(0,i.kt)("p",null,"L\u01b0u \xfd, unary l\xe0 right-associate operator, v\xec th\u1ebf ta g\u1ecdi \u0111\u1ec7 quy h\xe0m ",(0,i.kt)("inlineCode",{parentName:"p"},"unary")," ngay khi g\u1eb7p d\u1ea5u ",(0,i.kt)("inlineCode",{parentName:"p"},"!")," ho\u1eb7c ",(0,i.kt)("inlineCode",{parentName:"p"},"-"),". N\u1ebfu kh\xf4ng g\u1eb7p m\u1ed9t trong hai d\u1ea5u tr\xean, ta g\u1ecdi xu\u1ed1ng h\xe0m ",(0,i.kt)("inlineCode",{parentName:"p"},"primary"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"  def unary(tokens: List[Token]): ParseResult =\n    tokens match\n      case token :: rest =>\n        unaryOp(token) match\n          case Some(fn) => unary(rest).flatMap((expr, rmn) => Right(fn(expr), rmn))\n          case None     => primary(tokens)\n      case _ => primary(tokens)\n")),(0,i.kt)("h3",{id:"primary-expression"},"Primary expression"),(0,i.kt)("p",null,"C\xe0i \u0111\u1eb7t primary expression t\u01b0\u01a1ng \u0111\u1ed1i r\xf5 r\xe0ng"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"  def primary(tokens: List[Token]): ParseResult =\n    tokens match\n      case Literal.Number(l) :: rest  => Right(Expr.Literal(l.toDouble), rest)\n      case Literal.Str(l) :: rest     => Right(Expr.Literal(l), rest)\n      case Keyword.True :: rest       => Right(Expr.Literal(true), rest)\n      case Keyword.False :: rest      => Right(Expr.Literal(false), rest)\n      case Keyword.Nil :: rest        => Right(Expr.Literal(null), rest)\n      case Operator.LeftParen :: rest => parenBody(rest)\n      case _                          => Left(Error.ExpectExpression(tokens))\n")),(0,i.kt)("p",null,"Khi g\u1eb7p d\u1ea5u m\u1edf ngo\u1eb7c (left paren), ta ti\u1ebfp t\u1ee5c ch\u1ea1y rule ",(0,i.kt)("inlineCode",{parentName:"p"},"expression")," cho nh\u1eefng tokens ti\u1ebfp theo, sau \u0111\xf3 ki\u1ec3m tra token k\u1ebf ti\u1ebfp c\xf3 ph\u1ea3i d\u1ea5u \u0111\xf3ng ngo\u1eb7c hay kh\xf4ng."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"  def parenBody(\n    tokens: List[Token]\n  ): ParseResult = expression(tokens).flatMap((expr, rest) =>\n    rest match\n      case Operator.RightParen :: rmn => Right(Expr.Grouping(expr), rmn)\n      case _                          => Left(Error.ExpectClosing(rest))\n  )\n")))}m.isMDXComponent=!0}}]);