<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.14">
<title data-react-helmet="true">Representing Code | Grox</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://grokking-vietnam.github.io//grox/docs/book/representing-code"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Representing Code | Grox"><meta data-react-helmet="true" name="description" content="Ở phần trước, chúng ta đã thử biến đổi source code từ dạng raw sang một list tokens. Hôm nay, chúng ta sẽ tiếp tục biểu diễn list token này sang 1 dạng phức tạp và đầy đủ hơn."><meta data-react-helmet="true" property="og:description" content="Ở phần trước, chúng ta đã thử biến đổi source code từ dạng raw sang một list tokens. Hôm nay, chúng ta sẽ tiếp tục biểu diễn list token này sang 1 dạng phức tạp và đầy đủ hơn."><link data-react-helmet="true" rel="icon" href="/grox/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://grokking-vietnam.github.io//grox/docs/book/representing-code"><link data-react-helmet="true" rel="alternate" href="https://grokking-vietnam.github.io//grox/docs/book/representing-code" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://grokking-vietnam.github.io//grox/docs/book/representing-code" hreflang="x-default"><link rel="stylesheet" href="/grox/assets/css/styles.d0db87f0.css">
<link rel="preload" href="/grox/assets/js/runtime~main.53ba92db.js" as="script">
<link rel="preload" href="/grox/assets/js/main.be6db770.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/grox/"><div class="navbar__logo"><img src="https://avatars.githubusercontent.com/u/9639466?s=45&amp;v=4" alt="Grox Language Logo" class="themedImage_TMUO themedImage--light_4Vu1"><img src="https://avatars.githubusercontent.com/u/9639466?s=45&amp;v=4" alt="Grox Language Logo" class="themedImage_TMUO themedImage--dark_uzRr"></div><b class="navbar__title">Grox</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/grox/docs">Learn</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/grokking-vietnam/grox" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_iYfV toggle_2i4l toggleDisabled_xj38"><div class="toggleTrack_t-f2" role="button" tabindex="-1"><div class="toggleTrackCheck_mk7D"><span class="toggleIcon_pHJ9">🌜</span></div><div class="toggleTrackX_dm8H"><span class="toggleIcon_pHJ9">🌞</span></div><div class="toggleTrackThumb_W6To"></div></div><input type="checkbox" class="toggleScreenReader_h9qa" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_lDyR"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_i9tI" type="button"></button><aside class="docSidebarContainer_0YBq"><div class="sidebar_a3j0"><nav class="menu thin-scrollbar menu_cyFh"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/grox/docs/">Mục lục</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/grox/docs/introduction">Introduction</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_TwRn" href="/grox/docs/book/lox-language">Crafting Interpeters</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/grox/docs/book/lox-language">lox-language</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/grox/docs/book/map-of-the-territory">Map of the territory</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/grox/docs/book/scanning">Scanning</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/grox/docs/book/representing-code">Representing Code</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/grox/docs/book/parsing-expression">Parsing Expression</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_TwRn" href="/grox/docs/fp/parser-combinators">Functional Programming</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/grox/docs/resources">Resources</a></li></ul></nav></div></aside><main class="docMainContainer_r8cw"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_zHA2"><div class="docItemContainer_oiyr"><article><div class="tocCollapsible_aw-L theme-doc-toc-mobile tocMobile_Tx6Y"><button type="button" class="clean-btn tocCollapsibleButton_zr6a">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Representing Code</h1></header><p>Ở phần trước, chúng ta đã thử biến đổi source code từ dạng raw sang một list tokens. Hôm nay, chúng ta sẽ tiếp tục biểu diễn list token này sang 1 dạng phức tạp và đầy đủ hơn.</p><p>Đầu tiên, chúng ta sẽ bắt đầu với 1 ví dụ đơn giản, làm thế nào để tính biểu thức sau:</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">1 + 2 * 3 - 4</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Chúng ta đều biết quy tắc giải bài toán này đó là &quot;nhân chia trước, cộng trừ sau&quot;. Trên máy tính, nó có thể được biểu diễn bằng cấu trúc cây. Trong đó, số là các node lá và toán tử là các node trong. </p><p><img src="https://craftinginterpreters.com/image/representing-code/tree-evaluate.png"></p><p>Để tính được giá trị của biểu thức, chúng ta sẽ phải tính giá trị của các cây con trước. Tức là chúng ta phải thực hiện duyệt cây (tree traversal), trong ví dụ này chúng ta sẽ thực hiện post-order traversal.</p><p>Chúng ta thấy là nếu dùng cấu trúc cây để biểu diễn biểu thức trên thì việc tính toán trông khá dễ dàng. Vậy 1 cách trực quan nhất, liệu chúng ta có thể biểu diễn grammar của ngôn ngữ lập trình dưới dạng dạng cây hay không?</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="context-free-grammars">Context-Free Grammars<a class="hash-link" href="#context-free-grammars" title="Direct link to heading">​</a></h2><p>Ở bài trước, chúng ta cũng đã sử dụng lexical grammar để định nghĩa các tokens. Với Scanner thì cách làm này rất hiệu quả nhưng không đủ để handle các biểu thức lồng nhau rất phức tạp.</p><p>Vì vậy, chúng ta sẽ cần đến <strong>context-free grammar (CFG)</strong>.  Công cụ mạnh nhất trong các <a href="https://vi.wikipedia.org/wiki/Ng%C3%B4n_ng%E1%BB%AF_h%C3%ACnh_th%E1%BB%A9c" target="_blank" rel="noopener noreferrer">ngôn ngữ hình thức</a></p><blockquote><p>Một <strong>ngôn ngữ hình thức</strong> (<em>formal language</em>) được định nghĩa là một tập các chuỗi (<em>string</em>) được xây dựng dựa trên một <a href="https://vi.wikipedia.org/wiki/B%E1%BA%A3ng_ch%E1%BB%AF_c%C3%A1i" target="_blank" rel="noopener noreferrer" title="Bảng chữ cái">bảng chữ cái</a> (<em>alphabet</em>), và chúng được ràng buộc bởi các <a href="https://vi.wikipedia.org/wiki/Lu%E1%BA%ADt" target="_blank" rel="noopener noreferrer" title="Luật">luật</a> (<em>rule</em>) hoặc <a href="https://vi.wikipedia.org/wiki/V%C4%83n_ph%E1%BA%A1m" target="_blank" rel="noopener noreferrer" title="Văn phạm">văn phạm</a> (<em>grammar</em>) đã được định nghĩa trước.</p><p>Wikipedia</p></blockquote><p>Bảng chữ cái ở đây có thể lấy từ ngôn ngữ tự nhiên hoặc tự định nghĩa</p><table><thead><tr><th>Terminology</th><th></th><th>Lexical grammar</th><th>Syntactic grammar</th></tr></thead><tbody><tr><td>The “alphabet” is . . .</td><td>→ </td><td>Characters</td><td>Tokens</td></tr><tr><td>A “string” is . . .</td><td>→ </td><td>Lexeme or token</td><td>Expression</td></tr><tr><td>It’s implemented by the . . .</td><td>→ </td><td>Scanner</td><td>Parser</td></tr></tbody></table><h2 class="anchor anchorWithStickyNavbar_y2LR" id="rules-for-grammars">Rules for grammars<a class="hash-link" href="#rules-for-grammars" title="Direct link to heading">​</a></h2><p>Chúng ta cần phải định nghĩa một tập giới hạn các quy tắc (rule) để tạo ra các strings. Rules trong trường hợp này gọi là <strong>productions</strong> vì chúng <em>produce</em> ra các strings.</p><p>Mỗi production(rule) trong CFG có phần đầu (head) - tên và phần thân (body) mô tả nó sẽ tạo ra cái gì. Ở dạng cơ bản nhất thì, phần thân chỉ bao gồm một danh sách các kí hiệu (Symbols). Các kí hiệu có 2 kiểu:</p><ul><li><strong>Terminal</strong> là một chữ cái trong bảng chữ cái. Chúng ta có thể nghĩ nó như là một literal. Trong syntactic grammar nó là các token chúng ta đã có được từ Scanner.</li><li><strong>Nonterminal</strong> dùng để chỉ đến 1 rule trong gammar.</li></ul><p>Chỉ còn 1 điều cuối cùng cần phải lưu ý:  Chúng ta có thể có nhiều rules có cùng tên. Khi chúng ta gặp một nonterminal với 1 tên nào đó chúng ta được phép chọn 1 rule bất kì cho nó.</p><p>Để biểu diễn được 1 cách cụ thể hơn, chúng ta cần một cách để viết ra các production rules này. Người ta đã tìm cách thực hiện điều này từ hàng ngàn năm về trước và cho đến khi John Backus và công ty của ông cần nó cho ngôn ngữ ALGOL 58 và cuối cùng tạo ra <strong>Backus-Naur form (BNF)</strong>. Và kể từ đó, hầu hết mọi người để sử dụng BNF (hoặc biến đổi của BNF).</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">breakfast  → protein &quot;with&quot; breakfast &quot;on the side&quot; ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">breakfast  → protein ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">breakfast  → bread ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">protein    → crispiness &quot;crispy&quot; &quot;bacon&quot; ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">protein    → &quot;sausage&quot; ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">protein    → cooked &quot;eggs&quot; ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">crispiness → &quot;really&quot; ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">crispiness → &quot;really&quot; crispiness ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cooked     → &quot;scrambled&quot; ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cooked     → &quot;poached&quot; ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cooked     → &quot;fried&quot; ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bread      → &quot;toast&quot; ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bread      → &quot;biscuits&quot; ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bread      → &quot;English muffin&quot; ;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Từ đó chúng ta có thể viết ra các strings dựa trên BNF ở trên:</p><p><img src="https://craftinginterpreters.com/image/representing-code/breakfast.png"></p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="a-grammar-for-lox-expressions">A Grammar for Lox expressions<a class="hash-link" href="#a-grammar-for-lox-expressions" title="Direct link to heading">​</a></h2><p>Syntatic Grammar phức tạp hơn Lexical Grammar rất là nhiều, vì vậy rất khó để trình bày được toàn bộ SG trong 1 lần giống như cách chúng ta làm ở phần Scanner. Vì vậy, chúng ta sẽ nghiền ngẫm từng tập con của ngôn ngữ và thêm syntax mới trong các chương tiếp theo. Hiện tại, chúng ta sẽ chỉ quan tâm đến expression:</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">expression     → literal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               | unary</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               | binary</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               | grouping ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">literal        → NUMBER | STRING | &quot;true&quot; | &quot;false&quot; | &quot;nil&quot; ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">grouping       → &quot;(&quot; expression &quot;)&quot; ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unary          → ( &quot;-&quot; | &quot;!&quot; ) expression ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">binary         → expression operator expression ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">operator       → &quot;==&quot; | &quot;!=&quot; | &quot;&lt;&quot; | &quot;&lt;=&quot; | &quot;&gt;&quot; | &quot;&gt;=&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               | &quot;+&quot;  | &quot;-&quot;  | &quot;*&quot; | &quot;/&quot; ;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Trên đây là các rule để chúng ta có thể biểu diễn được 1 expression giống như sau:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">1 - (2 * 3) &lt; 4 == false</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_y2LR" id="implementing-syntax-trees">Implementing Syntax Trees<a class="hash-link" href="#implementing-syntax-trees" title="Direct link to heading">​</a></h2><p>Dễ thấy, grammar của chúng ta có thể được biểu diễn bằng cấu trúc cây. Bởi vì cấu trúc này được dùng để biểu diễn syntax cho ngôn ngữ grox nên nó được gọi là <strong>syntax tree.</strong></p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="modelling-data-with-algebraic-data-type">Modelling Data with Algebraic Data Type<a class="hash-link" href="#modelling-data-with-algebraic-data-type" title="Direct link to heading">​</a></h3><p>Trong FP, ADT là một kiểu dữ liệu được tạo nên bằng cách kết hợp các kiểu dữ liệu khác.</p><p>Ví dụ 1: 1 biểu thức Binary sẽ <strong>có</strong> vế trái, về phái và 1 toán tử. Trong Scala chúng ta có thể biểu diễn kiểu Binary bằng 1 case class:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">case class Binary(left: Expr, operator: Operator, right: Expr)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Khi đó, Binary được gọi là 1 Product Type</p><p>Ví dụ 2: 1 Literal <strong>có thể là</strong> Number hoặc String. Với Scala chúng ta có thể biểu diễu Literal bằng Enum hoặc Union Type</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">type Literal = Str | Number</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enum Literal:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Str, Number</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Khi đó, Literal được gọi là 1 Sum type</p><p>Trong Scala 3, khái niệm <code>enum</code> để rộng để có thể biểu diễn luôn một ADT hoàn chỉnh hay thậm chí là một Generalize ADT (GADT).</p><p>Ví dụ chúng ta có thể định nghĩa expression của grammar trên trong Scala 3 như sau:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">enum Expr:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Binary(left: Expr, o: Operator, right: Expr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Unary(o: Operator, expr: Expr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Grouping(expr: Expr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Literal(o: Str | Number)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Tuy nhiên ở chương này, chúng ta sẽ define Expr một cách tường minh hơn bằng cách tách biệt Binary thành các phép toán số học như bên dưới:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">enum Expr:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Add(left: Expr, right: Expr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Subtract(left: Expr, right: Expr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Multiply(left: Expr, right: Expr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Divide(left: Expr, right: Expr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Negate(expr: Expr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Minus(expr: Expr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Number(value: Int | Double)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Str(value: String)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Grouping(expr: Expr)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Để đơn giản, trong chương này chúng ta sẽ quan tâm đến một số phép tính số học, trong các phần sau chúng ta sẽ tìm hiểu thêm về các biểu thức logic.</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="working-with-trees">Working with Trees<a class="hash-link" href="#working-with-trees" title="Direct link to heading">​</a></h2><p>OOP vs FP</p><p><img src="https://craftinginterpreters.com/image/representing-code/table.png"></p><p>Chúng ta thấy rằng, với mỗi kiểu expression chúng ta sẽ có 1 số các operations đi kèm với nó.</p><p>Trong các ngôn ngữ OOP như Java, code của chúng ta thường sẽ theo hướng là các ô trên cùng 1 hàng sẽ dính liền với nhau. Tức là các kiểu expression sẽ share chung với nhau các operation.</p><p><img src="https://craftinginterpreters.com/image/representing-code/rows.png"></p><p>Vì vậy, khi chúng ta thêm 1 kiểu expression mới, thì code của chúng ta sẽ rất đơn giản. Chúng ta không cần phải động vào các kiểu expression đã có mà chỉ cần &quot;extends&quot; thêm 1 kiểu mới. Nhưng khi chúng ta muốn thêm 1 operation mới, thì chúng ta phải quay lại và sửa lại tất cả các expression đã có.</p><p>Đối với các ngôn ngữ FP như ML. Type và Operation tách biệt nhau, mỗi kiểu expression khác nhau thì chúng có các operation khác nhau cho kiểu đó. Vì vậy, các ô trong cùng 1 cột sẽ dính liền với nhau.</p><p><img src="https://craftinginterpreters.com/image/representing-code/columns.png"></p><p>Trong FP, khi chúng ta muốn định nghĩa 1 function cho nhiều kiểu expression khác nhau. Chúng ta sẽ dùng đến pattern matching. Khi chúng ta thêm 1 operation mới, chúng ta sẽ không cần sửa các operation khác. Tuy nhiên, khi chúng ta có thêm 1 kiểu mới, chúng ta phải quay lại và sửa code của tất cả các operation đã có.</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="a-not-very-pretty-printer">A (Not Very) Pretty Printer<a class="hash-link" href="#a-not-very-pretty-printer" title="Direct link to heading">​</a></h2><p>Khi chúng ta debug parser, chúng ta thường phải debug AST. Vì vậy chúng ta muốn có 1 format đẹp cho AST. Quá trình convert 1 AST sang string thường được gọi là &quot;pretty printing&quot;.</p><p>Thế nhưng, 1 printer không nên in ra những cái kiểu như <code>1 + 2 * 3</code> mà để phục vụ debug, chúng ta cần phải biểu diễn xem là phép toán nào đươc thực hiện trước, phép + hay phép * là đỉnh của cây.</p><p><img src="https://craftinginterpreters.com/image/representing-code/expression.png"></p><p>AST ở trên sẽ được in ra là (xem sourcecode):</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">(* (- 123) (group 45.67))</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/../grox-docs/target/mdoc/book/4-representing-code.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_mS5F" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_mt2f"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/grox/docs/book/scanning"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Scanning</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/grox/docs/book/parsing-expression"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Parsing Expression</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_vrFS thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#context-free-grammars" class="table-of-contents__link toc-highlight">Context-Free Grammars</a></li><li><a href="#rules-for-grammars" class="table-of-contents__link toc-highlight">Rules for grammars</a></li><li><a href="#a-grammar-for-lox-expressions" class="table-of-contents__link toc-highlight">A Grammar for Lox expressions</a></li><li><a href="#implementing-syntax-trees" class="table-of-contents__link toc-highlight">Implementing Syntax Trees</a><ul><li><a href="#modelling-data-with-algebraic-data-type" class="table-of-contents__link toc-highlight">Modelling Data with Algebraic Data Type</a></li></ul></li><li><a href="#working-with-trees" class="table-of-contents__link toc-highlight">Working with Trees</a></li><li><a href="#a-not-very-pretty-printer" class="table-of-contents__link toc-highlight">A (Not Very) Pretty Printer</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Learn</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/grox/docs/introduction">The Grox Programming Language</a></li><li class="footer__item"><a class="footer__link-item" href="/grox/docs/resources">Resources</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://www.grokking.org/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Grokking Vietnam<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://www.facebook.com/grokking.vietnam/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Facebook<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://www.youtube.com/channel/UCH2gAK9r_7EbvyVt0z5VibQ/featured" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Youtube<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/grokking-vietnam/grox" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Grokking Vietnam. Built with Docusaurus.</div></div></div></footer></div>
<script src="/grox/assets/js/runtime~main.53ba92db.js"></script>
<script src="/grox/assets/js/main.be6db770.js"></script>
</body>
</html>